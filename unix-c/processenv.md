# 进程环境

---

进程是操作系统的核心概念，学习进程的控制之前，需要先掌握进程的环境，这样我们就可以了解main程序是如何被调用的，命令行参数是如何传递给新程序的，典型的存储空间分布是什么样子，以及如何分配另外的存储空间，进程如何使用环境变量，进程如何终止等问题。

#### main函数
c程序总是从main函数开始的，在调用main之前会调用一个特殊的启动程序，一般是汇编程序，可执行文件一般把这个例程指定为程序的起始地址，这部分工作是连接器做的，启动例程从内核取得命令行参数和环境变量的值，然后为调用main函数做好准备。

#### 进程终止
进程终止有8种方式，其中五种是正常终止，3种异常终止：

1. 从main函数返回
2. 调用exit
3. 调用_exit,_Exit
4. 最后一个线程从其启动例程返回
5. 从最后一个线程调用pthread_exit
6. 调用abort（异常）
7. 接到一个信号（异常）
8. 最后一个线程对取消请求作出响应（异常）

一个进程可以登记最多32个终止处理函数，这些函数通过atexit注册，由exit自动调用，调用循序和他们登记时刚好相反，同一个函数如果登记多次，也会被调用多次。

```
#include<stdio.h>

int atexit(void(*func)(void));
//成功返回0，出错返回非0
```

#### 命令行参数
当执行一个新程序时，调用exec的进程可以把命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。

#### 环境表

每个程序都有一张环境表，环境表是一个字符指针数组，其中的每个指针包含一个NULL结尾的C字符串的地址，这串字符串就是一个环境变量，环境表可以通过环境指针environ获取。

#### C程序的存储空间分布
C程序由下列几部分组成：
- 正文段，只读可共享，是由CPU执行的机器指令部分，由exec从程序文件读入。
- 初始化数据段，由exec从文件读入。
- 未初始化数据段，他的内容并不由exec从文件读入并初始化为0，
- 栈
- 堆，历史原因，堆通常在栈和未初始化的数据段之间。
此外，程序文件还包括其它一些段，如符号表，调试信息等，但这些部分并不装载到进程执行的程序映像中。

#### 共享库
动态链接把公用的库函数提取出来，在程序第一次执行或者调用库函数时，把程序可共享库函数链接。使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区保存库的一个副本，这样减少了每个可执行文件的长度，增加了一些运行时的开销，共享库还有一个优点，可以不重新编译程序，只需用新的库替换老的库就可以实现升级。

#### 存储空间分配
ISO C提供了三个用于存储空间动态分配的函数：
- malloc，分配指定字节数的存储区，此存储区中的初始值不确定。
- calloc，分配指定字节数的存储区，该空间中的每一位都初始化为0。
- realloc， 增加或者减少以前分配区的长度，当增加长度时，可能需要把以前分配区的内容移到一个足够大的区域，以便在尾端提供增加的存储区，新增区域内的初始值不确定。
calloc和malloc相比就是他会把分配的存储区进行初始化，这一步往往比较耗时，有时候我们不需要初始化而需要更快速度的时候，应该用malloc。
申请的内存块用完之后需要主动去释放，不然会造成内存泄漏，随着内存泄漏越来越多，直至不再有空闲空间，这个时候由于换页开销很大，就会造成性能下降，系统也可能自动检测到异常进程，进程结束时，他的资源都会被回收，包括申请的内存，所以内存泄漏过多时内核有可能会主动杀死进程。此外，还可能产生的问题是释放一个已经释放的块，调用free时用的指针不是申请内存返回的指针。内存泄漏很难检查，而且C语言的内存管理考的都是程序员，所以编程的时候需要格外小心。


#### 环境变量
环境变量是一个字符串，内核并不查看这些字符串，如何解释这些字符串完全取决于应用程序，我们可以通过函数来获取环境变量和设置环境变量，需要关心的是设置环境变量我们只能影响当前进程和其后调用或者生成的任何子进程的环境。环境表和环境变量以及命令行参数一般存放在栈之上，位于存储空间的顶部，删除一个变量的时候，是在环境表中找到该变量，然后把后续指针顺次往表首部移动一个位置，如果是要修改或者增加一个环境变量，操作会复杂很多，因为向上已经到了进程地址空间的顶部，向下又是栈的空间，没有多的空间了，如果是新增加环境变量或者修改的环境变量大小超过了原来的环境变量，则需要malloc出一个空间。

#### 跳转
在C语言中，goto不能扩越函数跳转，替代goto垮函数跳转的是setjmp和longjmp，他们和goto的作用都一样，用来处理深层嵌套出错处理十分方便。

#### 易失变量
在调用longjmp之后，我们使用的一些自动变量在调用前后是不一样的，而所有的标准都称他们的值是不确定的，如果我们希望这些变量保持调用longjmp后的值，则可以定义它为具有volatite属性。声明为全局变量或者静态变量的值在执行longjmp时保持不变。我们在编译程序时可以带一些优化选项，全局变量，静态变量以及易失变量不会受优化影响。如编写一个使用非局部跳转的可移植程序，必须使用volatile属性。



















